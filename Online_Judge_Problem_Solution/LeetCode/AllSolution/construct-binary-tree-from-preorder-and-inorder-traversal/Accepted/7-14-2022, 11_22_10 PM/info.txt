{"id":747109237,"lang":"cpp","time":"3 weeks, 6 days","timestamp":1657819330,"status_display":"Accepted","runtime":"41 ms","url":"/submissions/detail/747109237/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.5 MB","code":"class Solution {\npublic:\n\tTreeNode *func(vector<int> &pre, vector<int> &in , unordered_map<int,int> &m, int ind, int leftind, int rightind){\n\t\tif(ind>=pre.size() or leftind>rightind) return NULL;// when preorder is fully travered or left ind > right index\n    \n\t\tTreeNode *root=new TreeNode(pre[ind]);// created new root node where pre[ind] is value of it\n    \n\t\tint x=m[root->val];//pivot\n    \n\t\troot->left= func(pre, in, m, ind+1, leftind, x-1);// forming left subtree\n\t\troot->right= func(pre, in, m, ind+x-leftind+1, x+1, rightind);// forming right subtree\n\t\treturn root;\n\t}\n\n\tTreeNode* buildTree(vector<int>& pre, vector<int>& in) {\n\t\tint n=pre.size();\n\t\tunordered_map<int,int>m;// HashMap increasing by time complexity to O(n)\n\t\tfor(int i=0;i<n;i++){\n\t\t\tm[in[i]]=i;\n\t\t}\n\t\tTreeNode *ans=func(pre, in , m, 0, 0, n-1);\n\t\treturn ans;\n\t}\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}